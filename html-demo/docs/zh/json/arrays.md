# 数组差异比较

数组差异比较是通过[最长公共子序列（LCS）](http://en.wikipedia.org/wiki/Longest_common_subsequence_problem)实现的，这是文本差异工具所使用的经典算法（此处用数组项代替文本行）。

这意味着数组增量能够很智能地处理序列（数组）中添加和删除的项。
但这里有一个很大的陷阱：**默认情况下，数组中的对象总是会被视为不同的，即使它们在你看来“看起来”是相等的**，要解决这个问题，你需要……

## 对象哈希（Object Hash）

为了让LCS算法生效，它需要一种方法来匹配前后（或左右）数组中的项。
在传统的文本差异工具中，这很简单，因为两行文本会逐字符进行比较。

默认情况下，会使用`===`运算符，这对于匹配所有JavaScript值类型（数字、字符串、布尔值）以及对象引用（如果你在左右状态之间保留了引用）来说已经足够了。

但是，当通过引用或值都没有找到匹配项时，数组差异比较会退化为一种简单的行为：**按位置匹配项**。

按位置匹配并不是最高效的选择（例如，如果在第一个位置添加了一个项，那么下面所有的项都会被视为已修改），但在大多数简单情况下，它能产生预期的结果。只要移动/插入/删除操作只发生在数组的末尾附近，这种方式就足够了。

这是因为如果两个对象在引用上不相等（即不是同一个对象），那么这两个对象会被视为不同的值，因为在JavaScript中，没有一种简单的方法可以比较两个任意的对象。

要利用LCS的强大功能（以及位置移动检测）来改进结果，你需要提供一种比较两个对象的方法，即`objectHash`函数：

### 使用objectHash的示例

```ts
const delta = jsondiffpatch
  .create({
    objectHash: function (obj, index) {
      // 尝试找到id属性，否则就使用数组中的索引
      return obj.name || obj.id || obj._id || '$$index:' + index;
    },
  })
  .diff({ name: 'tito' }, { name: 'tito' });

assert(delta === undefined); // 没有差异
```

## 移动（Moves）

作为对LCS的后续改进，在同一个数组中从一个位置移动到另一个位置的项会被检测到，并被记录为移动。

这带来了一些好处：

- 增量可能会小得多，因为不会两次包含项的整个值（添加和删除）
- 补丁操作只会在目标数组中移动项，而不是删除并插入一个新实例。这样更高效，并且可能防止破坏对象图中的现有引用。
- 如果被移动的项是一个对象或数组，差异比较会继续在其内部进行（嵌套差异比较）

移动检测默认是开启的，你可以通过以下方式关闭移动检测：

```ts
const customDiffPatch = jsondiffpatch.create({
  arrays: {
    detectMove: false,
  },
});
```

### 表示方式

#### JSON增量

```js
{
  "_originalIndex": // 这是项在数组中的原始位置
  [
    '', // 被移动项的值，默认情况下会被省略
    destinationIndex, // 这是项在数组中的最终位置
    3 // 用于表示数组移动的魔术数字
  ]
}
```

> 注意：在某些情况下，`originalIndex`和`destinationIndex`可能是相同的数字，这看起来可能很奇怪，但要记住，前者指的是原始状态（下划线就是这个意思），后者指的是最终状态。在打补丁时，项会先被全部删除，最后再全部插入，所以在这个过程中，数组的组成可能已经发生了变化。

更多细节请查看[增量格式文档](deltas.md)

#### HTML

在HTML中，移动的项会显示为精美的弯曲箭头（查看[在线演示](https://jsdiff.com/json)），这些是通过SVG元素和嵌入的脚本标签实现的，只有在[你的浏览器支持SVG](http://caniuse.com/svg)时才会显示。